## Project 2实验手册

> 

现在是时候开始着手处理系统中允许**运行用户程序**的部分了。基本代码已经支持加载和运行用户程序，但不支持I/O或交互。在这个项目中，您将允许程序通过系统调用与操作系统交互。

您将在**userprog目录**下完成此任务，但您也将与Pintos的几乎所有其他部分进行交互。我们将在下面描述相关部分。

您可以在项目1提交的基础上构建项目2，也可以重新开始。**此任务不需要项目1中的代码**。“闹钟”功能在项目3和项目4中可能有用，但并非严格要求。

在上一个项目中，我们将测试代码直接编译到内核中，因此我们必须在内核中要求特定的函数接口。从现在起，我们将通过运行用户程序来测试您的操作系统。这给了你更大的自由。您必须确保用户程序界面符合此处描述的规范，但考虑到该约束，您可以随意重新构造或重写内核代码。

您将需要与此项目的文件系统代码进行接口，因为用户程序是从文件系统加载的，并且您必须实现的许多系统调用都与文件系统进行处理。但是，本项目的重点不是文件系统，因此我们在**filesys目录**中提供了一个简单但完整的文件系统。您需要查看**`filesys.h`和`file.h`接口**，以了解如何使用文件系统，尤其是它的许多限制。
不需要修改此项目的文件系统代码，因此我们建议您不要修改。在文件系统上工作可能会分散您对本项目重点的注意力。

### 建议实现顺序

- 参数传递（参见第3.3.3节参数传递）
- 用户内存访问（参见第3.1.5节访问用户内存）。所有系统调用都需要读取用户内存。很少有系统调用需要写入用户内存。
- 系统调用基础设施（参见第3.3.4节系统调用）。实现足够的代码，以便从用户堆栈读取系统调用号，并基于它分派给处理程序。
- 退出系统调用。以正常方式完成的每个用户程序都调用exit。即使是从main（）返回的程序也会间接地调用exit（参见lib/user/entry.c中的_start（））。
- 写入系统调用，用于写入系统控制台fd 1。我们所有的测试程序都会写入控制台（printf（）的用户进程版本就是这样实现的），因此在写入可用之前，它们都会出现故障。
- 现在，将进程_wait（）更改为无限循环（一个永远等待的循环）。提供的实现会立即返回，因此Pintos将在任何进程实际运行之前关闭。您最终需要提供一个正确的实现。

### 任务介绍

- **3.3.2过程终止消息**
  每当用户进程因调用exit或任何其他原因而终止时，请打印该进程的名称和退出代码，其格式与打印F相同（“%s:exit（%d）\n”，…）；。打印的名称应该是传递给进程_execute（）的全名，忽略命令行参数。当不是用户进程的内核线程终止或调用halt系统调用时，不要打印这些消息。当进程加载失败时，该消息是可选的。
  除此之外，不要打印Pintos提供的尚未打印的任何其他邮件。在调试期间，您可能会发现额外的消息很有用，但它们会混淆分级脚本，从而降低您的分数。

- **3.3.3参数传递**

  当前，process_execute（）不支持向新进程传递参数。通过扩展process_execute（）来实现此功能，这样它就不用简单地将程序文件名作为参数，而是在空格处将其划分为单词。第一个字是程序名，第二个字是第一个参数，依此类推。也就是说，process_execute（“grep foo bar”）应该通过两个参数foo和bar运行grep。

- **系统调用**

- 在`userprog/syscall.c`中实现系统调用处理程序。我们提供的框架实现通过终止进程来“处理”系统调用。它需要检索系统调用号，然后检索任何系统调用参数，并执行适当的操作。
  - **void halt（void）**
    通过调用shutdown_power_off（）（在`devices/shutdown.h`中声明）终止Pintos。这应该很少使用，因为您会丢失一些关于可能的死锁情况等的信息。
    
  - **void exit (int status)**
    终止当前用户程序，将状态返回内核。如果进程的父进程等待它（见下文），则将返回此状态。通常，状态为0表示成功，非零值表示错误。
    
  - **pid_t exec (const char *cmd_line)**
    运行名称在cmd_line中给定的可执行文件，传递任何给定参数，并返回新进程的程序id（pid）。如果程序由于任何原因无法加载或运行，则必须返回pid-1，否则该pid不应是有效的pid。因此，在知道子进程是否成功加载其可执行文件之前，父进程无法从exec返回。您必须使用适当的同步来确保这一点。
  
  - **int wait (pid_t pid)**
  
    等待子进程pid并检索子进程的退出状态。
  
    如果pid仍处于活动状态，则等待它终止。然后，返回pid传递给exit的状态。如果pid没有调用exit（），但被内核终止（例如，由于异常而终止），那么wait（pid）必须返回-1。父进程等待在父进程调用wait时已经终止的子进程是完全合法的，但是内核仍然必须允许父进程检索其子进程的退出状态，或者知道子进程已被内核终止。
  
  - **bool create (const char *file, unsigned initial_size)**
  
    创建一个名为file initially_size字节的新文件。如果成功，则返回true，否则返回false。创建新文件不会打开它：打开新文件是一个单独的操作，需要打开系统调用。
  
  - **bool remove (const char *file)**
  
    删除名为file的文件。如果成功，则返回true，否则返回false。无论文件是打开的还是关闭的，都可以将其删除，删除打开的文件不会将其关闭。有关详细信息，请参见删除打开的文件。
  
  - **int open (const char *file)**
  
    打开名为file的文件。返回称为“文件描述符”（fd）的非负整数句柄，如果无法打开文件，则返回-1。
  
    编号为0和1的文件描述符为控制台保留：fd 0（标准输入文件号）为标准输入，fd 1（标准输出文件号）为标准输出。开放系统调用永远不会返回这些文件描述符中的任何一个，它们仅作为系统调用参数有效，如下所述。
  
    每个进程都有一组独立的文件描述符。子进程不会继承文件描述符。
  
    当单个文件被多次打开时，无论是由单个进程还是不同的进程打开，每次打开都会返回一个新的文件描述符。
  
  - **int filesize (int fd)**
  
    返回作为fd打开的文件的大小（以字节为单位）。
  
  - **int read (int fd, void *buffer, unsigned size)**
  
    从作为fd打开的文件中读取大小字节到缓冲区中。返回实际读取的字节数（文件末尾为0），如果无法读取文件（由于文件结尾以外的条件），则返回-1。Fd 0使用input_getc（）从键盘读取数据。
  
  - **int write (int fd, const void *buffer, unsigned size)**
  
    将大小字节从缓冲区写入打开的文件fd。返回实际写入的字节数，如果某些字节无法写入，则可能小于大小。
  
  - **void seek (int fd, unsigned position)**
  
    将打开文件fd中要读取或写入的下一个字节更改为位置，以文件开头的字节表示。（因此，位置0是文件的起点。）
    超过文件当前结尾的搜索不是错误。稍后的读取获得0字节，表示文件结束。稍后的写入扩展文件，用零填充任何未写入的间隙。（然而，在Pintos中，在项目4完成之前，文件的长度是固定的，因此写入文件末尾将返回一个错误。）这些语义在文件系统中实现，在系统调用实现中不需要任何特殊的工作。
  
  - **unsigned tell (int fd)**
  
    返回打开文件fd中要读取或写入的下一个字节的位置，以从文件开头开始的字节数表示。
  
  - **void close (int fd)**
  
    关闭文件描述符fd。退出或终止进程会隐式关闭其所有打开的文件描述符，就像为每个描述符调用此函数一样。

该文件定义了其他系统调用。暂时忽略它们。您将在项目3中实现其中一些，在项目4中实现其余部分，因此请确保在设计系统时考虑可扩展性。

> 要实现系统调用，您需要提供在用户虚拟地址空间中读取和写入数据的方法。在获得系统调用号之前，您需要此功能，因为系统调用号位于用户虚拟地址空间中的用户堆栈上。这可能有点棘手：如果用户提供了无效的指针、指向内核内存的指针或其中一个区域的部分块，该怎么办？您应该通过终止用户进程来处理这些情况。我们建议在实现任何其他系统调用功能之前编写和测试此代码。有关更多信息，请参阅第3.1.5节访问用户内存。

您必须同步系统调用，以便任意数量的用户进程可以同时进行调用。特别是，一次从多个线程调用filesys目录中提供的文件系统代码是不安全的。系统调用实现必须将文件系统代码视为关键部分。不要忘记，process_execute（）也会访问文件。目前，我们建议不要修改filesys目录中的代码。

我们在`lib/user/syscall.c`中为每个系统调用提供了一个用户级函数。这些为用户进程提供了一种从C程序调用每个系统调用的方法。每种方法都使用少量内联汇编代码来调用系统调用，并（如果合适）返回系统调用的返回值。

- **3.3.5拒绝写入可执行文件**
  添加代码以拒绝写入用作可执行文件的文件。许多操作系统之所以这样做，是因为如果进程试图运行磁盘上正在更改的代码，会产生不可预测的结果。一旦在项目3中实现了虚拟内存，这一点就显得尤为重要，但即使现在也不会有什么坏处。
  您可以使用file_deny_write（）防止写入打开的文件。对该文件调用file_allow_write（）将重新启用它们（除非该文件被另一个打开程序拒绝写入）。关闭文件还将重新启用写入。因此，要拒绝对进程可执行文件的写入，必须在进程仍在运行时保持其打开状态。

### 目标开始

#### 系统调用是什么？

在 Pintos 中，用户程序调用整数 $0x30进行系统调用，此时用户就会把没有权限干的活交给系统调用去干，系统调用的栈指针就是esp，返回值是eax。**我们需要干的事说白了就是根据esp指向栈的参数内容，完成系统调用对应的功能，最后把返回值放到eax里。**

#### judge_ptr()

根据Pintos文档描述

> 要实现系统调用，您需要提供在用户虚拟地址空间中读取和写入数据的方法。**在获得系统调用号之前，您需要此功能，因为系统调用号位于用户虚拟地址空间中的用户堆栈上。**这可能有点棘手：如果用户提供了无效的指针、指向内核内存的指针或其中一个区域的部分块，该怎么办？您应该通过终止用户进程来处理这些情况。**我们建议在实现`任何其他系统调用功能`之前编写和测试此代码。**有关更多信息，请参阅第3.1.5节访问用户内存。

因此，我们需要**自定义**一个判断函数，**来完成判断用户提供的指针指向的地址是否合法**。

支持读取和写入用户内存以进行系统调用。

至少有两种合理的方法可以正确地做到这一点。

第一种方法是验证用户提供的指针的有效性，然后取消引用它。如果您选择这条路线，您将需要查看 `userprog/pagedir.c`和`threads/vaddr.h`中的函数。这是处理用户内存访问的最简单方法。

第二种方法是只检查用户指针是否指向下方`PHYS_BASE`，然后取消引用它。无效的用户指针将导致“页面错误”，你可以通过修改代码的处理`page_fault()`在 `userprog / exception.c`。这种技术通常更快，因为它利用了处理器的`MMU`，所以它往往用于实际内核（包括`Linux`）。

<img src="Project 2实验手册.assets/image-20211125004412847.png" alt="image-20211125004412847" style="zoom:67%;" /><img src="Project 2实验手册.assets/image-20211125004547119.png" alt="image-20211125004547119" style="zoom:67%;" />

